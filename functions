#!/bin/bash

set -eu
set -o pipefail

# Library of functions for the kayobe development environment.

FUNCTIONS_PARENT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
export KAYOBE_AUTOMATION_UTILS_PATH="$FUNCTIONS_PARENT/utils"
export KAYOBE_AUTOMATION_REPO_ROOT="$FUNCTIONS_PARENT/.."
export KAYOBE_AUTOMATION_DIR="${KAYOBE_AUTOMATION_DIR:-$KAYOBE_AUTOMATION_REPO_ROOT/.automation.conf}"

export _LOG_LEVEL_DEBUG=4000
export _LOG_LEVEL_INFO=3000
export _LOG_LEVEL_WARN=2000
export _LOG_LEVEL_ERROR=1000

# Utility functions

function log_level {
    case "${KAYOBE_AUTOMATION_LOG_LEVEL:-warn}" in
    debug)
        echo -n "$_LOG_LEVEL_DEBUG"
        ;;

    info)
        echo -n "$_LOG_LEVEL_INFO"
        ;;

    error)
        echo -n "$_LOG_LEVEL_ERROR"
        ;;

    *)
        echo -n "$_LOG_LEVEL_WARN"
        ;;
    esac
}

function log_info {
    if [ "$(log_level)" -ge $_LOG_LEVEL_INFO ]; then
        msg="[INFO]: $@"
        echo "$msg" 1>&2
        if [ ! -z ${LOGDIR:+x} ]; then
            echo "$msg" >> "${LOGDIR}/kayobe-automation.log"
        fi
    fi
}

function log_warn {
    if [ "$(log_level)" -ge $_LOG_LEVEL_WARN ]; then
        msg="[WARNING]: $@"
        echo "$msg" 1>&2
        if [ ! -z ${LOGDIR:+x} ]; then
            echo "$msg" >> "${LOGDIR}/kayobe-automation.log"
        fi
    fi
}

function log_debug {
    if [ "$(log_level)" -ge $_LOG_LEVEL_DEBUG ]; then
        msg="[DEBUG]: $@"
        echo "$msg" 1>&2
        if [ ! -z ${LOGDIR:+x} ]; then
            echo "$msg" >> "${LOGDIR}/kayobe-automation.log"
        fi
    fi
}

function log_error {
    if [ "$(log_level)" -ge $_LOG_LEVEL_ERROR ]; then
        msg="[ERROR]: $@"
        echo "$msg" 1>&2
        if [ ! -z ${LOGDIR:+x} ]; then
            echo "$msg" >> "${LOGDIR}/kayobe-automation.log"
        fi
    fi
}

# Prints backtrace info
# filename:lineno:function
# backtrace level
function backtrace {
    local level=$1
    local deep
    deep=$((${#BASH_SOURCE[@]} - 1))
    echo "[Call Trace]"
    while [ $level -le $deep ]; do
        echo "${BASH_SOURCE[$deep]}:${BASH_LINENO[$deep-1]}:${FUNCNAME[$deep-1]}"
        deep=$((deep - 1))
    done
}

# Prints line number and "message" then exits
# die $LINENO "message"
function die {
    local exitcode=$?
    set +o xtrace
    local line=$1; shift
    if [ $exitcode == 0 ]; then
        exitcode=1
    fi
    backtrace 2
    _err $line "$*"
    # Give buffers a second to flush
    sleep 1
    exit $exitcode
}


# Prints line number and "message" in error format
# _err $LINENO "message"
function _err {
    local exitcode=$?
    local xtrace
    xtrace=$(set +o | grep xtrace)
    set +o xtrace
    local msg="[ERROR] ${BASH_SOURCE[2]}:$1 $2"
    echo "$msg" 1>&2;
    if [ ! -z ${LOGDIR:+x} ]; then
        echo "$msg" >> "${LOGDIR}/kayobe-automation.log"
    fi
    $xtrace
    return $exitcode
}

function environment_diagnostics {
    set -x
    whoami
    set +x
}

function pause {
   echo "Press [Enter] to continue..."
   read -p "$*"
}

function function_exists {
    declare -f -F $1 > /dev/null
    return $?
}

function call {
    if function_exists $1; then
        $1
    fi
}

function call_with_hooks {
    call "pre_$1"
    call "$1"
    call "post_$1"
}

function is_absolute_path {
    path="$1"
    case "$path" in
        /*) true ;;
        *) false ;;
    esac
}

# Configuration

function config_defaults {
    # Set default values for kayobe development configuration.

    export KAYOBE_BRANCH="${KAYOBE_BRANCH:-stable/ussuri}"
    export OPENSTACK_SERIES="${OPENSTACK_SERIES:-$(echo ${KAYOBE_BRANCH} | sed 's|stable/||')}"
    export KAYOBE_URI="https://github.com/openstack/kayobe"
    export UPPER_CONSTRAINTS_FILE="${UPPER_CONSTRAINTS_FILE:-https://releases.openstack.org/constraints/upper/${OPENSTACK_SERIES}}"
    export KAYOBE_PIP_INSTALL_ARGS="-c ${UPPER_CONSTRAINTS_FILE}"

    export KAYOBE_CONFIG_SOURCE_PATH="${KAYOBE_CONFIG_SOURCE_PATH:-${FUNCTIONS_PARENT}/..}"

   # Additional arguments to pass to kayobe commands.
    export KAYOBE_EXTRA_ARGS=${KAYOBE_EXTRA_ARGS:-}

    export KAYOBE_AUTOMATION_LOG_LEVEL=${KAYOBE_AUTOMATION_LOG_LEVEL:-warn}

    # Log directory in case of errors
    export LOGDIR=${LOGDIR:-/tmp/logs}

    # Ansible defaults
    export ANSIBLE_FORCE_COLOR=${ANSIBLE_FORCE_COLOR:-True}

    # SSH key to use. This exists for documentation purposes. It is not recommended
    # to set it in config.sh
    export KAYOBE_AUTOMATION_SSH_PRIVATE_KEY=${KAYOBE_AUTOMATION_SSH_PRIVATE_KEY:-}
}

function config_set {
    # Source the configuration file, config.sh
    source "${KAYOBE_AUTOMATION_DIR}/config.sh"
}

function config_check {
    # Check the configuration environment variables.
    set +u
    if [[ -z "$KAYOBE_CONFIG_SOURCE_PATH" ]]; then
        if [[ ${KAYOBE_CONFIG_REQUIRED:-1} -eq 1 ]]; then
            die $LINENO "KAYOBE_CONFIG_SOURCE_PATH must be set"
        fi
    fi
    if [[ ! -e "$KAYOBE_CONFIG_SOURCE_PATH" ]]; then
        if [[ ${KAYOBE_CONFIG_REQUIRED:-1} -eq 1 ]]; then
            die $LINENO "Kayobe configuration path $KAYOBE_CONFIG_SOURCE_PATH does not exist"
        fi
    fi
    set -u
}

function config_init {
    config_defaults
    config_set
    config_check
    mkdir -p "$LOGDIR"
}

# Installation

function is_dnf {
    test -e /usr/bin/dnf
}

function workaround_start_sshd {
    # Kayobe will try and keyscan localhost which will fail if sshd not running
    # See: https://github.com/openstack/kayobe/blob/869185ea7be5d6b5b21c964a620839d5475196fd/ansible/roles/bootstrap/tasks/main.yml#L31
    if ! pgrep -x "sshd" > /dev/null
    then
        sudo_if_available /usr/bin/ssh-keygen -A
        sudo_if_available /usr/sbin/sshd &
    fi
}

function sudo_if_available {
    if [[ -e "/usr/bin/sudo" ]]; then
        sudo "$@"
        return
    fi
    "$@"
}

function install_dependencies {
    echo "Installing package dependencies for kayobe"
    if is_dnf; then
        sudo_if_available dnf -y install gcc git vim python3-pyyaml python3-virtualenv libffi-devel openssh-clients
    else
        sudo_if_available apt install -y python-dev python3-virtualenv gcc git libffi-dev openssh-client
    fi
}

function setup_ssh_agent {
    if [ ! -z ${KAYOBE_AUTOMATION_SSH_PRIVATE_KEY:+x} ]; then
        log_info "Setting up SSH agent to use private key"
        eval $(ssh-agent -s)
        echo "$KAYOBE_AUTOMATION_SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
    fi
}

function install_venv {
    # Install a virtualenv at $1. The rest of the arguments are passed
    # directly to pip.
    venv_path="$1"
    shift
    pip_paths="$@"
    local venv_parent="$(dirname ${venv_path})"
    if [[ ! -d "$venv_parent" ]]; then
        mkdir -p "$venv_parent"
    fi
    if [[ ! -f "${venv_path}/bin/activate" ]]; then
        echo "Creating virtual environment in ${venv_path}"
        virtualenv -p python3 "${venv_path}"
        # NOTE: Virtualenv's activate and deactivate scripts reference an
        # unbound variable.
        set +u
        source "${venv_path}/bin/activate"
        pip install -U pip
        pip install $pip_paths
        deactivate
        set -u
    else
        echo "Using existing virtual environment in ${venv_path}"
    fi
}

function install_kayobe_venv {
    local KAYOBE_ANSIBLE_PATH="$1/share/kayobe/ansible"
    # Install the Kayobe venv.
    install_venv "$1" $2
    # We need access to group_vars and plugins and if this venv can move it means that we can't
    # create a symlink to a known location. Plugins could be set with an environment variable.
    cp -rfp "$FUNCTIONS_PARENT"/ansible/ "$KAYOBE_ANSIBLE_PATH/.."
}

function create_kayobe_environment {
    env=$1
    mkdir -p "$env"/{src/kayobe,src/kayobe-config,venvs/kayobe}
    git clone $KAYOBE_URI "$env/src/kayobe"
    cp -rf "$KAYOBE_CONFIG_SOURCE_PATH" "$env/src/kayobe-config"
    local KAYOBE_PIP_INSTALL_ARGS="$KAYOBE_PIP_INSTALL_ARGS $env/src/kayobe"
    install_kayobe_venv "$env/venvs/kayobe" "$KAYOBE_PIP_INSTALL_ARGS"
}

# Runtime

function environment_setup {
    env=$(mktemp -d --suffix -kayobe-env)
    create_kayobe_environment "$env"
    # NOTE: Virtualenv's activate script references an unbound variable.
    set +u
    source "$env/venvs/kayobe/bin/activate"
    set -u
    source "$env/src/kayobe-config/kayobe-env"
}

function run_kayobe {
    # Run a kayobe command, including extra arguments provided via
    # $KAYOBE_EXTRA_ARGS.
    kayobe "${@}" ${KAYOBE_EXTRA_ARGS}
}

function control_host_bootstrap {
    echo "Bootstrapping the Ansible control host"
    local KAYOBE_EXTRA_ARGS=${KAYOBE_BOOTSTRAP_EXTRA_ARGS:-}
    for i in $(seq 1 3); do
        if run_kayobe control host bootstrap; then
            chb_success=1
            break
        fi
        echo "Control host bootstrap failed - likely Ansible Galaxy flakiness. Retrying"
    done
    if [[ -z ${chb_success+x} ]]; then
        die $LINENO "Failed to bootstrap control host"
    fi
    echo "Bootstrapped control host after $i attempts"
}

function kayobe_init {
    call_with_hooks validate
    call_with_hooks config_init
    call_with_hooks environment_diagnostics
    call_with_hooks install_dependencies
    call_with_hooks workaround_start_sshd
    call_with_hooks setup_ssh_agent
    call_with_hooks environment_setup
    call_with_hooks control_host_bootstrap
}
